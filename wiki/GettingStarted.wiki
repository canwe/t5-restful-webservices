#labels Featured,Phase-Deploy
#How to get up and running with t5-restful-webservices

= Introduction =

*Version 0.2.0 -- major re-write*

This Tapestry 5 contributed library enables IoC services you write to handle RESTful web service requests.

This is done by writing methods in your service class with the {{{@RestfulWebMethod}}} annotation and using Tapestry's {{{Response}}} to render an appropriate response to the browser.  You then contribute instances of those services to this library's {{{RestfulWSDispatcher}}} service.

{{{RestfulWSDispatcher}}} adds a {{{RequestFilter}}} to Tapestry 5's pipline to trap HTTP requests intended to be serviced by the RESTful web methods you have written.


= Details =

==Install==

Just drop the source jar (t5-restful-webservices.jar) into the classpath for your Tapestry 5 application.  No other configuration is necessary.  Yes, Tapestry 5 makes it that simple!

==Do a little planning==

You need to come up with a unique, _URL-friendly_ string id for each of your web service classes.  HTTP requests that have such a unique id will be handled by a method on your service, rather than a Tapestry component or event.

Let's start an example.  Let's imagine that our Tapestry 5 web application is rooted at the URL {{{http://myapp.example.org/}}} -- i.e., the root context is "/" and that exact URL returns the root Index.java T5 page.

Now imagine we want a RESTful web method named "foo", in a web service class named "MyWebService", to return some XML to the browser, based on a string argument and a boolean argument to that web method: 

{{{
<foo>
   <stringArg>bar</stringArg>
   <booleanArg>true</booleanArg>
</foo>
}}}

So, we need to come up with a unique string id that identifies the MyWebService class.  The simple name of the class is a compelling choice, but of course you might have the web service classes with the same simple name in different classes.  The fully-qualified is another possibility, but those can be awfully long and expose your class package structure, which you might not want to do.  Let's just use "my-web-service".

The URL to use the web service is {{{http://myapp.example.org/<unique-id>/<method-name>/args...}}}.  So in this example it will be

{{{http://myapp.example.org/my-web-service/foo/bar/true}}}

==Write your Tapestry 5 IoC Service==

Implement is easy.  We implement a Tapestry 5 IoC service as normal, providing the method "foo".  That method must be annotated with {{{@RestfulWebMethod}}}, which is provided by this library.  Also, the web method _must_ take the Tapestry {{{Request}}} and {{{Response}}} objects as its first two arguments, in that order: 

{{{

    @RestfulWebMethod
    public void foo (Request request, Response response, String s, boolean b) throws IOException
    {
        PrintWriter writer = response.getPrintWriter("text/xml");
        writer.append("<foo>");
        writer.append("<stringArg>" + s + "</stringArg>");
        writer.append("<booleanArg>" + b + "</booleanArg>");
        writer.append("</foo>");
        writer.flush();
        writer.close();
    }

    // Other methods, restful or otherwise...
}}}

The {{{Request}}} object is provided for your convenience, and based on feedback, I might eliminate it.  The {{{Response}}} object is necessary, of course, for you to render appropriate content back to the browser.

==Contribute your service to the RESTful web service module==

In your application's IoC module, you need to contribute your service to the {{{RestfulWSDispatcher}}}.  The dispatcher takes a mapped configuration with the key for each service being its unique id.  With our example,

{{{
public void contributeRestfulWSDispatcher (MappedConfiguration<String, Object> config)
{
    config.add("my-web-service", new MyWebService());        
}
}}}